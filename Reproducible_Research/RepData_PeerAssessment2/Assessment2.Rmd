---
title: Analysis of NOAA Storm Data to Investigate the Effect of Storms on Public Health
  and the Economy
author: "Sean Clarke"
date: "19/05/2015"
output: html_document
---

# Synopsis


# Data Processing

I obtained data from the U.S. National Oceanic and Atmospheric Administration's (NOAA) storm database which records the details of major weather events in the US along with estimates of their impact on the population and economy.

## Reading in the data

Firstly we download the file and unzip it in the code in order to help to ensure reproducability. The file is provided on the NOAA website but for the purposes of this exercise has also been [mirrored seperately](https://d396qusza40orc.cloudfront.net/repdata%2Fdata%2FStormData.csv.bz2). The file is a CSV file that is served up compressed using bzip2.

```{r cache = TRUE}
DataDir <- "Data"
FilePath <- paste(DataDir, "Stormdata.csv.bz2", sep="/")

dir.create(DataDir, showWarnings=FALSE) 

## Only download if the file doesnt exist
if (! file.exists(FilePath)){
download.file("https://d396qusza40orc.cloudfront.net/repdata%2Fdata%2FStormData.csv.bz2",FilePath , method="curl")
}

## No need to decompress, read.csv knows what to do
## ColsToKeep used to select interesting columns
ColsToKeep <- c("BGN_DATE", "BGN_TIME", "TIME_ZONE", "STATE", "EVTYPE", "FATALITIES", "INJURIES", "PROPDMG", "PROPDMGEXP", "CROPDMG", "CROPDMGEXP")
StormData <- read.csv(FilePath, stringsAsFactors = FALSE)[,ColsToKeep]
```

The dataset is massive so we take the opportunity to drop the columns that we have no interest in at this point. We keep the following columns `r ColsToKeep`.

After reading in this dataset we take the chance to see what the structure of the dataset looks like.

```{r}
dim(StormData)
head(StormData)
```

## Processing the Data

Next we want to tidy up the data - first of all we need to combine PROPDMG/PROPDMGEXP and CROPDMG/CROPDMGEXP. The "EXP" columns provide the exponentiation for the value stored in the corresponding "DMG" columne. The symbols, K, M and B respectively representing 10^3, 10^6 and 10^9.

There is however a complication - there are additional values in this column which arent well described in the information page.

```{r}
unique(StormData$PROPDMGEXP)
unique(StormData$CROPDMGEXP)
```
We next investigate how important the undefined symbols are in this range

```{r}
require(dplyr)
aggregate(StormData$PROPDMGEXP, by=list(StormData$PROPDMGEXP), FUN=length)
aggregate(StormData$CROPDMGEXP, by=list(StormData$PROPDMGEXP), FUN=length)
StormData %>%
    filter(PROPDMGEXP %in% c("K","M","B", "")) %>%
    summarise(Total=n())
StormData %>%
    filter(!(PROPDMGEXP %in% c("K","M","B", ""))) %>%
    summarise(Total=n())
StormData %>%
    filter(CROPDMGEXP %in% c("K","M","B", "")) %>%
    summarise(Total=n())
StormData %>%
    filter(!(CROPDMGEXP %in% c("K","M","B", ""))) %>%
    summarise(Total=n())

```

This shows us that the only undefined symbol that is likely to be statistically significant is "". Lets have a close look at that one.

```{r}
StormData %>%
    filter(CROPDMGEXP =="") %>%
    group_by(CROPDMGEXP,CROPDMG) %>%
    summarise(Total=n())
```

```{r}
StormData %>%
    filter(PROPDMGEXP =="") %>%
    group_by(PROPDMGEXP,PROPDMG) %>%
    summarise(Total=n())
```
So from this analysis, we can conclude that when the columns representing exponentiation are empty then the number of cases where the corresponding value column isnt equal to 0 is statistically insignificant.

Therefore for the purposes of this analysis, only the rows where PROPDMGEXP and CROPDMGEXP are equal to K, M or B are considered - all other observations will be set to NA so that they can be discarded in further analysis. We cannot just filter rows as on some occasions there are valid entries in PROPDMGEXP and undefined ones in CROPDMGEXP and vice-versa.


We use a dplyr pipe to start to work through this - first of all we replace K with 1000, M with 1000000 and then B with 1000000000 and then multiple the two columns togther.

```{r}

StormData <- StormData %>%
        #filter(PROPDMGEXP %in% c("K", "M", "B") & CROPDMGEXP %in% c("K", "M", "B")) %>%
        mutate(PROPDMGEXP=ifelse(!(PROPDMGEXP %in% c("K", "M", "B")) , NA, PROPDMGEXP)) %>%
        mutate(CROPDMGEXP=ifelse(!(CROPDMGEXP %in% c("K", "M", "B")) , NA, CROPDMGEXP)) %>%
        mutate(PROPDMGEXP=ifelse(PROPDMGEXP=="K", 1000, PROPDMGEXP)) %>%
        mutate(PROPDMGEXP=ifelse(PROPDMGEXP=="M", 1000000, PROPDMGEXP)) %>%
        mutate(PROPDMGEXP=ifelse(PROPDMGEXP=="B", 1000000000, PROPDMGEXP)) %>%
        mutate(CROPDMGEXP=ifelse(CROPDMGEXP=="K", 1000, CROPDMGEXP)) %>%
        mutate(CROPDMGEXP=ifelse(CROPDMGEXP=="M", 1000000, CROPDMGEXP)) %>%
        mutate(CROPDMGEXP=ifelse(CROPDMGEXP=="B", 1000000000, CROPDMGEXP)) %>%
        mutate(PROPDMGEVL=PROPDMG*as.numeric(PROPDMGEXP))
```



# Results
